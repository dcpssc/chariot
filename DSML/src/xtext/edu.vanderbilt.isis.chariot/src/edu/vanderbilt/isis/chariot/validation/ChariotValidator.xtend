/*
 * generated by Xtext
 */
package edu.vanderbilt.isis.chariot.validation



import org.eclipse.xtext.validation.Check 
import edu.vanderbilt.isis.chariot.chariot.ChariotPackage
import edu.vanderbilt.isis.chariot.chariot.Component

//import edu.vanderbilt.isis.chariot.chariot.InteractionEventTriggerBasic
//import edu.vanderbilt.isis.chariot.chariot.BufferedReceiverPort
//import edu.vanderbilt.isis.chariot.chariot.ServerPort
//import edu.vanderbilt.isis.chariot.chariot.ClientPort
import edu.vanderbilt.isis.chariot.chariot.SystemObjective
//import edu.vanderbilt.isis.chariot.chariot.SporadicTrigger
//import edu.vanderbilt.isis.chariot.chariot.periodicTrigger
//import edu.vanderbilt.isis.chariot.chariot.ChariotComponent
import edu.vanderbilt.isis.chariot.chariot.Functionality
import java.util.ArrayList
//import edu.vanderbilt.isis.chariot.chariot.Workflow
import java.util.Set
import java.util.HashSet
//import edu.vanderbilt.isis.chariot.chariot.ProvidedFunctionality
//import edu.vanderbilt.isis.chariot.chariot.FunctionalityUsedPort
import edu.vanderbilt.isis.chariot.chariot.FunctionalityParam
//import edu.vanderbilt.isis.chariot.chariot.SenderPort

/**
 * Custom validation rules. 
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ChariotValidator extends AbstractChariotValidator {

//	@Check
//	def checkSporadicTrigger(SporadicTrigger x) {
//		if (x.firststartEvent == null && x.secondstartEvent==null && (x.portevents==null || x.portevents.size()==0)) {
//			error('The trigger should at least have one firing condition', null)
//		}
//	}
//	@Check 
//	def checkProvidedFunctionality(ProvidedFunctionality x){
//		var f= x.functionality
//		for(up: x.usedPorts)
//		{
//			var port =up.port
//			
//			var boolean result = isDirectionInput(f,up.functionalityParam)
//			if(result)
//			{
//				if (port instanceof SenderPort)	{
//					error ('a sender port cannot be associated with an input functionality parameter',null)
//				}
//			}
//			else{
//				if (port instanceof BufferedReceiverPort)	{
//					error ('a buffered receiver port cannot be associated with an input functionality parameter',null)
//				}
//			}
//		}
//	}
//	
	def isDirectionInput(Functionality functionality, FunctionalityParam par) {
		var inputlist = functionality.inputFunctionalityParam
		if(inputlist!=null)
		{
			for (param:inputlist.inputParams){
				if (param==par) return true
			}
		}
		return false
	}
	
//	@Check
//	def checkPeriodicTrigger(periodicTrigger x) {
//		if (x.period <=0) {
//			error('The trigger should have a period which is greater than 0', null)
//		}
//	}
	
//	@Check
//	def checkClientPortDifferentMessageTypes(ClientPort x) {
//		if (x.requestMessageType ==x.responseMessageType) {
//			error('request and response message types should be different', null)
//		}
//	}
//	@Check
//	def checkServerPortDifferentMessageTypes(ServerPort x) {
//		if (x.requestMessageType ==x.responseMessageType) {
//			error('request and response message types should be different', null)
//		}
//	}
	
//   @Check
//	def checkSingleFunctionality(ChariotComponent x) {
//		var functionalities = new HashSet<Functionality>
//		for (workflow : x.parts.filter(Workflow)) {
//			for (function : workflow.providedFunctionality) {
//				functionalities.add(function.functionality)
//
//			}
//			for (mode : workflow.modes) {
//				for (function : mode.providedFunctionality) {
//					functionalities.add(function.functionality)
//
//				}
//
//			}
//
//		}
//		if(functionalities.size >1)
//		{
//			error('A component is restricted to only one provided functionality', null)	
//		}
//
//	}
//	@Check
//	def checkSingleComponentOnly(Component s) {
//		var x = s.eContainer
//		var i = 2
//		if (x instanceof GlobalPackageDeclaration) {
//			i = (x as GlobalPackageDeclaration).elements.filter(typeof(Component)).size
//		} else if (x instanceof LocalPackageDeclaration) {
//			i = (x as LocalPackageDeclaration).elements.filter(typeof(Component)).size
//		}
//		if (i > 1) {
//			error('At most one component can be defined in a file.', null)
//		}
//	}
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}